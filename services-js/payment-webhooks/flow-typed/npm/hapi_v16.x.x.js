// flow-typed signature: f69763863e3f1ac17494e276084ed40f
// flow-typed version: <<STUB>>/hapi_v^16.1.0/flow_v0.38.0


/**
 * This is an autogenerated libdef stub for:
 *
 *   'hapi'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

declare module 'hapi' {
  import type { ClientRequest, ServerResponse } from 'http';
  import type { Readable } from 'stream';

  declare export type AuthenticationInfo = {|
    isAuthenticated: boolean,
    credentials: Object,
    artifacts: Object,
    mode: any,
    error: any,
  |};

  declare export type RequestInfo = {|
    acceptEncoding: string,
    cors: ?{|
      isOriginMatch: boolean,
    |},
    host: string,
    hostname: string,
    received: number,
    referrer: string,
    remoteAddress: string,
    remotePort: string,
    responded: number,
  |};

  declare type ReadableFile = {|
    ...Readable,
    hapi: {|
      filename: string,
      headers: {[name: string]: string},
    |},
  |}

  declare type PreObject = {|
    method?: RouteHandlerFunction | 'string',
    assign?: 'string',
    failAction: 'error' | 'log' | 'ignore',
  |};

  declare type PreHandler =
    | PreObject
    | RouteHandlerFunction
    | string;

  declare type Payload = Object | Buffer | Readable | ReadableFile;

  declare export class Request {
    app: Object;
    auth: AuthenticationInfo;
    connection: any;
    domain: ?domain$Domain;
    headers: Object;
    id: string,
    info: RequestInfo;
    method: 'get' | 'post' | 'put' | 'options' | 'delete';
    orig: ?{|
      params: Object,
      query: string,
      payload: any,
    |};
    params: {[name: string]: string};
    paramsArray: Array<string>;
    path: string;
    payload: Payload;
    plugins: Object;
    pre: {[name: string]: PreHandler};
    response: ?Response;
    preResponse: ?Response;
    query: string | {[key: string]: string | Array<string>};
    raw: {|
      req: ClientRequest,
      res: ServerResponse,
    |},
    route: any,
    server: Server,
    state: any,
    url: any,
  }

  declare export type ReplyContent =
    | null
    | typeof undefined
    | string
    | number
    | boolean
    | Buffer
    | Error
    | Readable
    | Object
    | Array<ReplyContent>;

  declare type EtagOptions = {|
    weak?: boolean,
    vary?: boolean,
  |};

  declare type HeaderOptions = {|
    append?: string,
    separator?: string,
    override?: boolean,
    duplicate?: boolean,
  |};

  declare type CookieOptions = Object;

  declare type ReplacerType = Function | Array<any>;

  declare export class Response {
    statusCode: number;
    headers: {[header: string]: string};
    source: ReplyContent | Promise<ReplyContent>;
    variety: 'plain' | 'buffer' | 'stream' | 'promise';
    app: Object;
    plugins: Object;

    settings: {|
      charset: string,
      encoding: string,
      passThrough: boolean,
      stringify: any,
      ttl: string,
      varyEtag: boolean,
    |};
    
    isBoom: boolean;

    bytes(length: number): this;
    charset(charset: string): this;
    code(statusCode: number): this;
    message(httpMessage: string): this;
    created(uri: string): this;
    encoding(encoding: string): this;
    etag(tag: string, options?: EtagOptions): this;
    header(name: string, value: string, options?: HeaderOptions): this;
    location(uri: string): this;
    redirect(uri: string): this;
    replacer(method: ReplacerType): this;
    spaces(count: number): this;
    state(name: string, value: string | Object, options?: CookieOptions): this;
    suffix(suffix: string): this;
    ttl(msec: number): this;
    type(mimeType: string): this;
    unstate(name: string, options?: CookieOptions): this;
    vary(header: string): this;
    hold(): this;
    send(): this;
    takeover(): this;

    temporary(isTemporary?: boolean): this;
    permanent(isPermanent?: boolean): this;
    rewritable(isRewritable?: boolean): this;
  }

  declare type ReplyEntityOptions = {|
    etag?: string,
    modified?: string,
    vary?: boolean,
  |};

  declare type ReplyCloseOptions = {|
    end?: boolean,
  |};

  declare export type Reply = {|
     (
      err?: ReplyContent | Promise<ReplyContent>,
      result?: ReplyContent | Promise<ReplyContent>,
      data?: Object
    ): Response,
    realm: any,
    request: Request,
    continue(result?: ReplyContent): void,
    entity(options: ReplyEntityOptions): void,
    close(options?: ReplyCloseOptions): void,
    redirect(uri: string): void,
    response(result: ReplyContent | Promise<ReplyContent>): void,
    state(name: string, value: string | Object, options?: CookieOptions): void,
    unstate(name: string, options?: CookieOptions): void,
  |};

  declare type ConnectionOptions = Object;
  declare type RegisterOptions = Object;

  declare type AccessRule = {|
    scope?: string | Array<string>,
    entity?: 'any' | 'user' | 'app',
  |};

  declare type AuthOptions = {|
    mode?: 'required' | 'optional' | 'try',
    strategies?: Array<string>,
    payload?: false | 'required' | 'optional',
    access?: AccessRule | Array<AccessRule>,
  |};

  declare type CacheOptions = {|
    privacy?: 'default' | 'public' | 'private',
    expiresIn?: number,
    expiresAt?: string,
    statuses?: Array<number>,
    otherwise?: string,
  |};

  declare type CorsOptions = {|
    origin?: Array<string>,
    maxAge?: number,
    headers?: Array<string>,
    additionalHeaders?: Array<string>,
    exposedHeaders?: Array<string>,
    additionalExposedHeaders?: Array<string>,
    credentials?: boolean,
  |};

  declare type FilesOptions = {|
    relativeTo?: string,
  |};

  declare type JsonOptions = {|
    replacer?: ReplacerType,
    space?: number,
    suffix?: string,
    escape?: boolean,
  |};

  declare type PayloadFailHandler = (request: Request, reply: Reply, error: any) => void;

  declare type PayloadOptions = {|
    output?: 'data' | 'stream' | 'file',
    parse?: boolean | 'gunzip',
    multipart?: false | {|
      output?: 'data' | 'stream' | 'file' | 'annotated',
    |},
    allow?: string | Array<string>,
    override?: string,
    maxBytes?: number,
    timeout?: false | number,
    uploads?: string,
    failAction?: 'error' | 'log' | 'ignore' | PayloadFailHandler,
    defaultContentType?: string,
    compression?: {[contentEncoding: string]: Object},
  |};

  declare type ResponseFailHandler = (request: Request, reply: Reply, source: string, error: any) => void;

  declare type JoiOptions = Object;
  declare type JoiValidation = Object;
  declare type ResponseValidationFunction = (value: ReplyContent, options: Object, next: (err: ?Object, value?: ReplyContent) => void) => void;
  declare type ResponseSchema = boolean | JoiValidation | ResponseValidationFunction;

  declare type ResponseOptions = {|
    emptyStatusCode?: number,
    failAction?: 'error' | 'log' | ResponseFailHandler,
    modify?: boolean,
    options?: JoiOptions,
    ranges?: boolean,
    sample?: number,
    schema?: ResponseSchema,
    status?: {[code: number]: ResponseSchema},
  |};

  declare type SecurityOptions = {|
    hsts?: true | number | {|
      maxAge?: number,
      includeSubdomains?: boolean,
      preload?: boolean,
    |},
    xframe?: true | {|
      rule: 'deny' | 'sameorigin' | 'allow-from',
      source?: string,
    |},
    xss?: boolean,
    noOpen?: boolean,
    noSniff?: boolean,
  |};

  declare type StateOptions = {|
    parse?: boolean,
    failAction?: 'error' | 'log' | 'ignore',
  |};

  declare type ValidationFunction<V> = (
    value: V,
    options: Object,
    next: (err?: any, value?: V) => void
  ) => void;

  declare type ValidateOptions = {|
    headers?: boolean | JoiValidation | ValidationFunction<{[name: string]: string}>,  
    params?: boolean | JoiValidation | ValidationFunction<{[name: string]: string}>,
    query?: boolean | JoiValidation | ValidationFunction<{[name: string]: string | Array<string>}>,
    payload?: boolean | JoiValidation | ValidationFunction<Payload>,
    errorFields?: Object,
    failAction?: 'error' | 'log' | 'ignore' | ResponseFailHandler,
    options?: JoiOptions,
  |};

  declare type TimeoutOptions = {|
    server?: false | number,
    socket?: (typeof undefined) | false | number,
  |};

  declare type RouteHandlerFunction = (request: Request, reply: Reply) => void | Response | Promise<void | Response>;
  declare type RouteHandlerObject = {
    $call?: empty
  };
  declare type RouteHandler = 
    | RouteHandlerFunction
    | RouteHandlerObject
    | string;

  declare type RouteConfig = {|
    app?: Object,
    auth?: false | string | AuthOptions,
    bind?: Object,
    cache?: CacheOptions,
    compression?: {[contentEncoding: string]: Object},
    cors?: boolean | CorsOptions,
    ext?: any,
    files?: FilesOptions,
    handler?: RouteHandler,
    id?: string,
    isInternal?: boolean,
    json?: JsonOptions,
    jsonp?: string,
    log?: boolean,
    payload?: PayloadOptions,
    plugins?: {[name: string]: Object},
    pre?: Array<PreHandler | Array<PreHandler>>,
    response?: ResponseOptions,
    security?: boolean | SecurityOptions,
    state?: StateOptions,
    validate?: ValidateOptions,
    timeout?: TimeoutOptions,

    description?: string,
    notes?: string | Array<string>,
    tags?: Array<string>,
  |};

  declare type RouteOptions = {|
    path: string,
    method: string | Array<string>,
    vhost?: string | Array<string>,
    handler?: RouteHandler,
    config?: RouteConfig | (server: Server) => RouteConfig,
  |};

  declare type AuthScheme = {|
    api?: Object,
    authenticate: RouteHandlerFunction,
    payload?: RouteHandlerFunction,
    response?: RouteHandlerFunction,
    options?: {|
      payload?: boolean,
    |},
  |};

  declare class ServerAuth {
    default(options: string | AuthOptions): void;
    scheme(name: string, scheme: (server: Server, options: Object) => AuthScheme): void;

    strategy(name: string, scheme: string): void;
    strategy(name: string, scheme: string, options: Object): void;
    strategy(name: string, scheme: string, mode: boolean): void;
    strategy(name: string, scheme: string, mode: boolean, options: Object): void;

    test(strategy: string, request: Request, next: (err: any, credentials: ?Object) => mixed): void;
  }

  declare export class Server {
    auth: ServerAuth;
    bind(context: Object): void;
    connection(opts: ConnectionOptions, address: string): void;
    register(opts: RegisterOptions): void;
    route(opts: RouteOptions): void;
    start(cb: (err: any) => mixed): void; 
    start(): Promise<void>;
    stop(cb: (err: any) => mixed): void; 
    stop(): Promise<void>; 
  }

  declare type Hapi = {|
    Server: typeof Server,
  |};

  declare export default Hapi;
}
